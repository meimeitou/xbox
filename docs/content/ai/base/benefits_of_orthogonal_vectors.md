+++
title = 'å‘é‡æ­£äº¤çš„è‰ºæœ¯'
weight = 14
math = true
description = 'æ¢ç´¢æ­£äº¤å‘é‡çš„ç¥å¥‡ä¸–ç•Œï¼Œæ­ç¤ºå®ƒä»¬åœ¨è®¡ç®—ã€å‡ ä½•ã€æœºå™¨å­¦ä¹ ç­‰é¢†åŸŸçš„å·¨å¤§ä¼˜åŠ¿ã€‚'
tags = ['çº¿æ€§ä»£æ•°', 'æ­£äº¤å‘é‡', 'è®¡ç®—ä¼˜åŒ–']
+++

ä¸ºä»€ä¹ˆ"å‚ç›´"å¦‚æ­¤é‡è¦ï¼Ÿ

- [å¼•è¨€](#å¼•è¨€)
- [1. è®¡ç®—ç®€åŒ–ï¼šè®©å¤æ‚è¿ç®—å˜å¾—ä¼˜é›…](#1-è®¡ç®—ç®€åŒ–è®©å¤æ‚è¿ç®—å˜å¾—ä¼˜é›…)
  - [1.1 å†…ç§¯è®¡ç®—çš„ç®€åŒ–](#11-å†…ç§¯è®¡ç®—çš„ç®€åŒ–)
  - [1.2 æŠ•å½±è®¡ç®—çš„æå¤§ç®€åŒ–](#12-æŠ•å½±è®¡ç®—çš„æå¤§ç®€åŒ–)
- [2. æ•°å€¼ç¨³å®šæ€§ï¼šè®¡ç®—æ›´å¯é ](#2-æ•°å€¼ç¨³å®šæ€§è®¡ç®—æ›´å¯é )
  - [2.1 é¿å…ç—…æ€çŸ©é˜µé—®é¢˜](#21-é¿å…ç—…æ€çŸ©é˜µé—®é¢˜)
  - [2.2 æ•°å€¼è¯¯å·®çš„æ§åˆ¶](#22-æ•°å€¼è¯¯å·®çš„æ§åˆ¶)
- [3. å‡ ä½•ç›´è§‚æ€§ï¼šç©ºé—´ç†è§£æ›´æ¸…æ™°](#3-å‡ ä½•ç›´è§‚æ€§ç©ºé—´ç†è§£æ›´æ¸…æ™°)
  - [3.1 ç‹¬ç«‹çš„æ–¹å‘](#31-ç‹¬ç«‹çš„æ–¹å‘)
  - [3.2 åæ ‡ç³»çš„è‡ªç„¶è¡¨ç¤º](#32-åæ ‡ç³»çš„è‡ªç„¶è¡¨ç¤º)
- [4. ç®—æ³•ä¼˜åŒ–ï¼šæ€§èƒ½çš„å·¨å¤§æå‡](#4-ç®—æ³•ä¼˜åŒ–æ€§èƒ½çš„å·¨å¤§æå‡)
  - [4.1 çŸ©é˜µè¿ç®—çš„ä¼˜åŒ–](#41-çŸ©é˜µè¿ç®—çš„ä¼˜åŒ–)
  - [4.2 çº¿æ€§æ–¹ç¨‹ç»„çš„å¿«é€Ÿæ±‚è§£](#42-çº¿æ€§æ–¹ç¨‹ç»„çš„å¿«é€Ÿæ±‚è§£)
- [5. å­˜å‚¨æ•ˆç‡ï¼šç©ºé—´çš„èŠ‚çº¦](#5-å­˜å‚¨æ•ˆç‡ç©ºé—´çš„èŠ‚çº¦)
  - [5.1 ç´§å‡‘çš„è¡¨ç¤º](#51-ç´§å‡‘çš„è¡¨ç¤º)
- [6. ä¿¡å·å¤„ç†ä¸­çš„åº”ç”¨](#6-ä¿¡å·å¤„ç†ä¸­çš„åº”ç”¨)
  - [6.1 é¢‘åŸŸåˆ†æ](#61-é¢‘åŸŸåˆ†æ)
- [7. æœºå™¨å­¦ä¹ ä¸­çš„å¨åŠ›](#7-æœºå™¨å­¦ä¹ ä¸­çš„å¨åŠ›)
  - [7.1 ä¸»æˆåˆ†åˆ†æï¼ˆPCAï¼‰](#71-ä¸»æˆåˆ†åˆ†æpca)
  - [7.2 ç¥ç»ç½‘ç»œä¸­çš„æƒé‡åˆå§‹åŒ–](#72-ç¥ç»ç½‘ç»œä¸­çš„æƒé‡åˆå§‹åŒ–)
- [8. è¯¯å·®åˆ†æå’Œè°ƒè¯•](#8-è¯¯å·®åˆ†æå’Œè°ƒè¯•)
  - [8.1 å¿«é€Ÿé”™è¯¯æ£€æµ‹](#81-å¿«é€Ÿé”™è¯¯æ£€æµ‹)
- [9. å¹¶è¡Œè®¡ç®—çš„ä¼˜åŠ¿](#9-å¹¶è¡Œè®¡ç®—çš„ä¼˜åŠ¿)
  - [9.1 ç‹¬ç«‹çš„è®¡ç®—](#91-ç‹¬ç«‹çš„è®¡ç®—)
- [10. æ€»ç»“ï¼šæ­£äº¤å‘é‡çš„åå¤§è¶…èƒ½åŠ›](#10-æ€»ç»“æ­£äº¤å‘é‡çš„åå¤§è¶…èƒ½åŠ›)
- [ç»“è¯­](#ç»“è¯­)

## å¼•è¨€

åœ¨çº¿æ€§ä»£æ•°çš„ä¸–ç•Œé‡Œï¼Œå‘é‡æ­£äº¤å°±åƒæ˜¯æ•°å­¦ä¸­çš„"è¶…çº§è‹±é›„"â€”â€”å®ƒä»¬æ‹¥æœ‰è®¸å¤šæ™®é€šå‘é‡æ²¡æœ‰çš„ç¥å¥‡èƒ½åŠ›ã€‚ä»Šå¤©æˆ‘ä»¬æ¥æ·±å…¥æ¢è®¨ä¸ºä»€ä¹ˆæ­£äº¤å‘é‡å¦‚æ­¤ç‰¹æ®Šï¼Œä»¥åŠå®ƒä»¬ä¸ºæˆ‘ä»¬å¸¦æ¥çš„ç§ç§å¥½å¤„ã€‚

## 1. è®¡ç®—ç®€åŒ–ï¼šè®©å¤æ‚è¿ç®—å˜å¾—ä¼˜é›…

### 1.1 å†…ç§¯è®¡ç®—çš„ç®€åŒ–

**æ­£äº¤å‘é‡çš„é»„é‡‘æ³•åˆ™**ï¼šæ­£äº¤å‘é‡çš„å†…ç§¯ä¸ºé›¶ï¼

```python
import numpy as np

# æ­£äº¤å‘é‡ç¤ºä¾‹
v1 = np.array([1, 0, 0])  # xè½´æ–¹å‘
v2 = np.array([0, 1, 0])  # yè½´æ–¹å‘
v3 = np.array([0, 0, 1])  # zè½´æ–¹å‘

print(f"v1 Â· v2 = {np.dot(v1, v2)}")  # 0
print(f"v1 Â· v3 = {np.dot(v1, v3)}")  # 0
print(f"v2 Â· v3 = {np.dot(v2, v3)}")  # 0
```

**ä¸ºä»€ä¹ˆè¿™å¾ˆé‡è¦ï¼Ÿ**

- ğŸ¯ **å¿«é€Ÿåˆ¤æ–­**ï¼šç«‹å³çŸ¥é“ä¸¤ä¸ªæ–¹å‘æ˜¯å¦ç‹¬ç«‹
- ğŸ’» **è®¡ç®—ä¼˜åŒ–**ï¼šå¾ˆå¤šç®—æ³•å¯ä»¥è·³è¿‡å¤æ‚çš„å†…ç§¯è®¡ç®—
- ğŸ” **é”™è¯¯æ£€æµ‹**ï¼šå¯ä»¥å¿«é€ŸéªŒè¯ç®—æ³•çš„æ­£ç¡®æ€§

### 1.2 æŠ•å½±è®¡ç®—çš„æå¤§ç®€åŒ–

å¯¹äºæ ‡å‡†æ­£äº¤åŸºï¼ŒæŠ•å½±è®¡ç®—å˜å¾—å¼‚å¸¸ç®€å•ï¼š

```python
def project_onto_orthonormal_basis(vector, basis):
    """åœ¨æ ‡å‡†æ­£äº¤åŸºä¸Šçš„æŠ•å½±"""
    projections = []
    for base_vector in basis:
        # å¯¹äºæ ‡å‡†æ­£äº¤åŸºï¼ŒæŠ•å½±ç³»æ•°å°±æ˜¯å†…ç§¯ï¼
        coefficient = np.dot(vector, base_vector)
        projections.append(coefficient * base_vector)
    return projections

# ç¤ºä¾‹ï¼šå°†å‘é‡æŠ•å½±åˆ°æ ‡å‡†æ­£äº¤åŸºä¸Š
vector = np.array([3, 4, 5])
standard_basis = [
    np.array([1, 0, 0]),
    np.array([0, 1, 0]),
    np.array([0, 0, 1])
]

projections = project_onto_orthonormal_basis(vector, standard_basis)
print("æŠ•å½±ç»“æœ:", projections)
# ç»“æœï¼šæ¯ä¸ªæŠ•å½±å°±æ˜¯åŸå‘é‡çš„å¯¹åº”åˆ†é‡ï¼
```

## 2. æ•°å€¼ç¨³å®šæ€§ï¼šè®¡ç®—æ›´å¯é 

### 2.1 é¿å…ç—…æ€çŸ©é˜µé—®é¢˜

**éæ­£äº¤åŸºçš„é—®é¢˜**ï¼š

```python
# å‡ ä¹çº¿æ€§ç›¸å…³çš„å‘é‡ï¼ˆç—…æ€æƒ…å†µï¼‰
bad_basis = np.array([
    [1.0, 1.0],
    [1.0, 1.000001]  # å‡ ä¹ç›¸åŒçš„æ–¹å‘
])

print("æ¡ä»¶æ•°:", np.linalg.cond(bad_basis))  # éå¸¸å¤§çš„æ•°ï¼
```

**æ­£äº¤åŸºçš„ä¼˜åŠ¿**ï¼š

```python
# æ­£äº¤åŸº
good_basis = np.array([
    [1.0, 0.0],
    [0.0, 1.0]
])

print("æ¡ä»¶æ•°:", np.linalg.cond(good_basis))  # æ¥è¿‘1ï¼
```

### 2.2 æ•°å€¼è¯¯å·®çš„æ§åˆ¶

æ­£äº¤å‘é‡å¸®åŠ©æ§åˆ¶ç´¯ç§¯è¯¯å·®ï¼š

```python
def demonstrate_numerical_stability():
    """æ¼”ç¤ºæ­£äº¤åŸºçš„æ•°å€¼ç¨³å®šæ€§"""
    
    # åˆ›å»ºä¸€ä¸ªå‘é‡
    original = np.array([1.0, 2.0, 3.0])
    
    # éæ­£äº¤åŸº
    non_orthogonal = np.array([
        [1.0, 0.1, 0.1],
        [0.1, 1.0, 0.1],
        [0.1, 0.1, 1.0]
    ])
    
    # æ­£äº¤åŸºï¼ˆå•ä½çŸ©é˜µï¼‰
    orthogonal = np.eye(3)
    
    # å¤šæ¬¡å˜æ¢åå†å˜æ¢å›æ¥
    result_non_orth = original.copy()
    result_orth = original.copy()
    
    for _ in range(100):
        # éæ­£äº¤åŸºçš„ç´¯ç§¯è¯¯å·®
        result_non_orth = non_orthogonal @ result_non_orth
        result_non_orth = np.linalg.inv(non_orthogonal) @ result_non_orth
        
        # æ­£äº¤åŸºçš„ç¨³å®šæ€§
        result_orth = orthogonal @ result_orth
        result_orth = orthogonal.T @ result_orth  # æ­£äº¤çŸ©é˜µçš„é€†å°±æ˜¯è½¬ç½®
    
    print(f"åŸå‘é‡: {original}")
    print(f"éæ­£äº¤åŸºç»“æœ: {result_non_orth}")
    print(f"æ­£äº¤åŸºç»“æœ: {result_orth}")
    print(f"éæ­£äº¤åŸºè¯¯å·®: {np.linalg.norm(result_non_orth - original)}")
    print(f"æ­£äº¤åŸºè¯¯å·®: {np.linalg.norm(result_orth - original)}")

demonstrate_numerical_stability()
```

## 3. å‡ ä½•ç›´è§‚æ€§ï¼šç©ºé—´ç†è§£æ›´æ¸…æ™°

### 3.1 ç‹¬ç«‹çš„æ–¹å‘

æ­£äº¤å‘é‡ä»£è¡¨å®Œå…¨ç‹¬ç«‹çš„æ–¹å‘ï¼š

```python
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

fig = plt.figure(figsize=(12, 5))

# 2Dæ­£äº¤å‘é‡
ax1 = fig.add_subplot(121)
ax1.arrow(0, 0, 1, 0, head_width=0.1, head_length=0.1, fc='red', ec='red', label='xè½´')
ax1.arrow(0, 0, 0, 1, head_width=0.1, head_length=0.1, fc='blue', ec='blue', label='yè½´')
ax1.set_xlim(-0.5, 1.5)
ax1.set_ylim(-0.5, 1.5)
ax1.grid(True)
ax1.set_aspect('equal')
ax1.legend()
ax1.set_title('2Dæ­£äº¤åŸºï¼šå®Œå…¨ç‹¬ç«‹çš„æ–¹å‘')

# 3Dæ­£äº¤å‘é‡
ax2 = fig.add_subplot(122, projection='3d')
ax2.quiver(0, 0, 0, 1, 0, 0, color='red', label='xè½´')
ax2.quiver(0, 0, 0, 0, 1, 0, color='blue', label='yè½´')
ax2.quiver(0, 0, 0, 0, 0, 1, color='green', label='zè½´')
ax2.set_xlim(0, 1)
ax2.set_ylim(0, 1)
ax2.set_zlim(0, 1)
ax2.legend()
ax2.set_title('3Dæ­£äº¤åŸºï¼šä¸‰ä¸ªç‹¬ç«‹æ–¹å‘')

plt.tight_layout()
plt.show()
```

### 3.2 åæ ‡ç³»çš„è‡ªç„¶è¡¨ç¤º

æ­£äº¤åŸºå°±æ˜¯æˆ‘ä»¬æ—¥å¸¸ä½¿ç”¨çš„åæ ‡ç³»ï¼

```python
def demonstrate_coordinate_system():
    """æ¼”ç¤ºæ­£äº¤åŸºä½œä¸ºåæ ‡ç³»çš„è‡ªç„¶æ€§"""
    
    # ä»»æ„ä¸€ä¸ªç‚¹
    point = np.array([3, 4, 5])
    
    # åœ¨æ ‡å‡†æ­£äº¤åŸºä¸‹çš„è¡¨ç¤º
    x_component = point[0]  # xæ–¹å‘çš„åˆ†é‡
    y_component = point[1]  # yæ–¹å‘çš„åˆ†é‡
    z_component = point[2]  # zæ–¹å‘çš„åˆ†é‡
    
    print(f"ç‚¹ {point} åœ¨æ­£äº¤åŸºä¸‹çš„åˆ†è§£ï¼š")
    print(f"xæ–¹å‘: {x_component}")
    print(f"yæ–¹å‘: {y_component}")  
    print(f"zæ–¹å‘: {z_component}")
    
    # éªŒè¯ï¼šåˆ†é‡çš„å¹³æ–¹å’Œç­‰äºé•¿åº¦çš„å¹³æ–¹ï¼ˆå‹¾è‚¡å®šç†ï¼ï¼‰
    length_squared = x_component**2 + y_component**2 + z_component**2
    actual_length_squared = np.dot(point, point)
    
    print(f"é•¿åº¦å¹³æ–¹ï¼ˆå‹¾è‚¡å®šç†ï¼‰: {length_squared}")
    print(f"å®é™…é•¿åº¦å¹³æ–¹: {actual_length_squared}")

demonstrate_coordinate_system()
```

## 4. ç®—æ³•ä¼˜åŒ–ï¼šæ€§èƒ½çš„å·¨å¤§æå‡

### 4.1 çŸ©é˜µè¿ç®—çš„ä¼˜åŒ–

**æ­£äº¤çŸ©é˜µçš„ç¥å¥‡æ€§è´¨**ï¼š

- **é€†çŸ©é˜µ = è½¬ç½®çŸ©é˜µ**ï¼š`Q^(-1) = Q^T`
- **è¡Œåˆ—å¼ = Â±1**ï¼š`det(Q) = Â±1`
- **ä¿æŒé•¿åº¦**ï¼š`||Qx|| = ||x||`

```python
def orthogonal_matrix_benefits():
    """æ¼”ç¤ºæ­£äº¤çŸ©é˜µçš„è®¡ç®—ä¼˜åŠ¿"""
    
    # åˆ›å»ºä¸€ä¸ªæ­£äº¤çŸ©é˜µï¼ˆæ—‹è½¬çŸ©é˜µï¼‰
    theta = np.pi / 4  # 45åº¦
    Q = np.array([
        [np.cos(theta), -np.sin(theta)],
        [np.sin(theta),  np.cos(theta)]
    ])
    
    print("æ­£äº¤çŸ©é˜µ Q:")
    print(Q)
    
    # éªŒè¯æ­£äº¤æ€§è´¨
    print(f"\nQ @ Q.T = \n{Q @ Q.T}")  # åº”è¯¥æ˜¯å•ä½çŸ©é˜µ
    print(f"det(Q) = {np.linalg.det(Q)}")  # åº”è¯¥æ˜¯1
    
    # è®¡ç®—é€†çŸ©é˜µï¼šå¯¹äºæ­£äº¤çŸ©é˜µï¼Œé€† = è½¬ç½®
    inverse_fast = Q.T  # O(1)æ“ä½œï¼
    inverse_slow = np.linalg.inv(Q)  # O(n^3)æ“ä½œ
    
    print(f"\nå¿«é€Ÿé€†çŸ©é˜µ(è½¬ç½®): \n{inverse_fast}")
    print(f"ä¼ ç»Ÿé€†çŸ©é˜µè®¡ç®—: \n{inverse_slow}")
    print(f"å·®å¼‚: {np.max(np.abs(inverse_fast - inverse_slow))}")

orthogonal_matrix_benefits()
```

### 4.2 çº¿æ€§æ–¹ç¨‹ç»„çš„å¿«é€Ÿæ±‚è§£

```python
def solve_with_orthogonal_matrix():
    """ä½¿ç”¨æ­£äº¤çŸ©é˜µå¿«é€Ÿæ±‚è§£çº¿æ€§æ–¹ç¨‹ç»„"""
    
    # æ–¹ç¨‹ç»„ Qx = bï¼Œå…¶ä¸­Qæ˜¯æ­£äº¤çŸ©é˜µ
    Q = np.array([
        [1/np.sqrt(2), -1/np.sqrt(2)],
        [1/np.sqrt(2),  1/np.sqrt(2)]
    ])
    
    b = np.array([1, 2])
    
    # ä¼ ç»Ÿæ–¹æ³•ï¼šx = Q^(-1) * b
    x_traditional = np.linalg.solve(Q, b)
    
    # æ­£äº¤çŸ©é˜µå¿«é€Ÿæ–¹æ³•ï¼šx = Q^T * b
    x_fast = Q.T @ b
    
    print(f"ä¼ ç»Ÿæ–¹æ³•ç»“æœ: {x_traditional}")
    print(f"å¿«é€Ÿæ–¹æ³•ç»“æœ: {x_fast}")
    print(f"å·®å¼‚: {np.max(np.abs(x_traditional - x_fast))}")

solve_with_orthogonal_matrix()
```

## 5. å­˜å‚¨æ•ˆç‡ï¼šç©ºé—´çš„èŠ‚çº¦

### 5.1 ç´§å‡‘çš„è¡¨ç¤º

æ­£äº¤çŸ©é˜µå¯ä»¥ç”¨æ›´å°‘çš„å‚æ•°è¡¨ç¤ºï¼š

```python
def rotation_matrix_parameterization():
    """æ¼”ç¤ºæ—‹è½¬çŸ©é˜µçš„ç´§å‡‘è¡¨ç¤º"""
    
    # 2Dæ—‹è½¬çŸ©é˜µåªéœ€è¦1ä¸ªå‚æ•°ï¼ˆè§’åº¦ï¼‰
    theta = np.pi / 3
    R_2d = np.array([
        [np.cos(theta), -np.sin(theta)],
        [np.sin(theta),  np.cos(theta)]
    ])
    
    print("2Dæ—‹è½¬çŸ©é˜µï¼ˆ4ä¸ªæ•°å­—ï¼Œä½†åªæœ‰1ä¸ªè‡ªç”±åº¦ï¼‰:")
    print(R_2d)
    
    # 3Dæ—‹è½¬çŸ©é˜µåªéœ€è¦3ä¸ªå‚æ•°ï¼ˆæ¬§æ‹‰è§’ï¼‰
    # è€Œä¸æ˜¯9ä¸ªçŸ©é˜µå…ƒç´ 
    print(f"\nå­˜å‚¨æ•ˆç‡: ç”¨1ä¸ªè§’åº¦å‚æ•°è¡¨ç¤º4ä¸ªçŸ©é˜µå…ƒç´ ")
    print(f"å‹ç¼©æ¯”: {4/1} : 1")

rotation_matrix_parameterization()
```

## 6. ä¿¡å·å¤„ç†ä¸­çš„åº”ç”¨

### 6.1 é¢‘åŸŸåˆ†æ

æ­£äº¤åŸºå‡½æ•°è®©ä¿¡å·åˆ†è§£å˜å¾—è‡ªç„¶ï¼š

```python
def fourier_basis_example():
    """æ¼”ç¤ºå‚…é‡Œå¶åŸºå‡½æ•°çš„æ­£äº¤æ€§"""
    
    # åˆ›å»ºæ—¶é—´åºåˆ—
    t = np.linspace(0, 2*np.pi, 100)
    
    # æ­£äº¤çš„æ­£å¼¦å’Œä½™å¼¦å‡½æ•°
    cos_1 = np.cos(t)
    sin_1 = np.sin(t)
    cos_2 = np.cos(2*t)
    sin_2 = np.sin(2*t)
    
    # éªŒè¯æ­£äº¤æ€§
    print("å‚…é‡Œå¶åŸºå‡½æ•°çš„æ­£äº¤æ€§:")
    print(f"cos(t) Â· sin(t) = {np.trapz(cos_1 * sin_1, t):.6f}")
    print(f"cos(t) Â· cos(2t) = {np.trapz(cos_1 * cos_2, t):.6f}")
    print(f"sin(t) Â· sin(2t) = {np.trapz(sin_1 * sin_2, t):.6f}")
    
    # ä¿¡å·åˆ†è§£ç¤ºä¾‹
    signal = 3 * cos_1 + 2 * sin_2  # å¤åˆä¿¡å·
    
    # æå–åˆ†é‡ï¼ˆåˆ©ç”¨æ­£äº¤æ€§ï¼‰
    cos_1_coeff = np.trapz(signal * cos_1, t) / np.trapz(cos_1 * cos_1, t)
    sin_2_coeff = np.trapz(signal * sin_2, t) / np.trapz(sin_2 * sin_2, t)
    
    print(f"\nä¿¡å·åˆ†è§£:")
    print(f"cos(t)çš„ç³»æ•°: {cos_1_coeff:.2f} (çœŸå®å€¼: 3)")
    print(f"sin(2t)çš„ç³»æ•°: {sin_2_coeff:.2f} (çœŸå®å€¼: 2)")

fourier_basis_example()
```

## 7. æœºå™¨å­¦ä¹ ä¸­çš„å¨åŠ›

### 7.1 ä¸»æˆåˆ†åˆ†æï¼ˆPCAï¼‰

```python
from sklearn.decomposition import PCA
from sklearn.datasets import make_blobs

def pca_orthogonality_demo():
    """æ¼”ç¤ºPCAä¸­æ­£äº¤ä¸»æˆåˆ†çš„é‡è¦æ€§"""
    
    # ç”Ÿæˆç¤ºä¾‹æ•°æ®
    X, _ = make_blobs(n_samples=100, centers=1, n_features=2, 
                      cluster_std=2.0, random_state=42)
    
    # åº”ç”¨PCA
    pca = PCA(n_components=2)
    X_pca = pca.fit_transform(X)
    
    # è·å–ä¸»æˆåˆ†ï¼ˆæ­£äº¤å‘é‡ï¼‰
    components = pca.components_
    
    print("ä¸»æˆåˆ†ï¼ˆæ­£äº¤å‘é‡ï¼‰:")
    print(f"ç¬¬ä¸€ä¸»æˆåˆ†: {components[0]}")
    print(f"ç¬¬äºŒä¸»æˆåˆ†: {components[1]}")
    
    # éªŒè¯æ­£äº¤æ€§
    orthogonality = np.dot(components[0], components[1])
    print(f"æ­£äº¤æ€§éªŒè¯ (åº”è¯¥æ¥è¿‘0): {orthogonality:.10f}")
    
    # è§£é‡Šçš„æ–¹å·®æ¯”ä¾‹
    print(f"è§£é‡Šçš„æ–¹å·®æ¯”ä¾‹: {pca.explained_variance_ratio_}")

pca_orthogonality_demo()
```

### 7.2 ç¥ç»ç½‘ç»œä¸­çš„æƒé‡åˆå§‹åŒ–

```python
def orthogonal_weight_initialization():
    """æ¼”ç¤ºæ­£äº¤æƒé‡åˆå§‹åŒ–çš„å¥½å¤„"""
    
    # éšæœºæƒé‡åˆå§‹åŒ–
    np.random.seed(42)
    random_weights = np.random.randn(100, 100)
    
    # æ­£äº¤æƒé‡åˆå§‹åŒ–
    orthogonal_weights, _ = np.linalg.qr(np.random.randn(100, 100))
    
    # è®¡ç®—æ¡ä»¶æ•°ï¼ˆè¡¡é‡æ•°å€¼ç¨³å®šæ€§ï¼‰
    cond_random = np.linalg.cond(random_weights)
    cond_orthogonal = np.linalg.cond(orthogonal_weights)
    
    print("æƒé‡çŸ©é˜µçš„æ¡ä»¶æ•°æ¯”è¾ƒ:")
    print(f"éšæœºåˆå§‹åŒ–: {cond_random:.2f}")
    print(f"æ­£äº¤åˆå§‹åŒ–: {cond_orthogonal:.2f}")
    print(f"æ”¹å–„æ¯”ä¾‹: {cond_random/cond_orthogonal:.2f}x")

orthogonal_weight_initialization()
```

## 8. è¯¯å·®åˆ†æå’Œè°ƒè¯•

### 8.1 å¿«é€Ÿé”™è¯¯æ£€æµ‹

```python
def error_detection_with_orthogonality():
    """åˆ©ç”¨æ­£äº¤æ€§è¿›è¡Œé”™è¯¯æ£€æµ‹"""
    
    def is_orthogonal_matrix(matrix, tolerance=1e-10):
        """æ£€æŸ¥çŸ©é˜µæ˜¯å¦æ­£äº¤"""
        should_be_identity = matrix @ matrix.T
        identity = np.eye(matrix.shape[0])
        error = np.max(np.abs(should_be_identity - identity))
        return error < tolerance, error
    
    # æµ‹è¯•æ­£ç¡®çš„æ­£äº¤çŸ©é˜µ
    correct_matrix = np.eye(3)
    is_orth_1, error_1 = is_orthogonal_matrix(correct_matrix)
    
    # æµ‹è¯•é”™è¯¯çš„çŸ©é˜µ
    wrong_matrix = np.array([[1, 0.1], [0, 1]])
    is_orth_2, error_2 = is_orthogonal_matrix(wrong_matrix)
    
    print("æ­£äº¤æ€§æ£€æµ‹:")
    print(f"å•ä½çŸ©é˜µ: æ­£äº¤={is_orth_1}, è¯¯å·®={error_1:.2e}")
    print(f"é”™è¯¯çŸ©é˜µ: æ­£äº¤={is_orth_2}, è¯¯å·®={error_2:.2e}")

error_detection_with_orthogonality()
```

## 9. å¹¶è¡Œè®¡ç®—çš„ä¼˜åŠ¿

### 9.1 ç‹¬ç«‹çš„è®¡ç®—

æ­£äº¤å‘é‡çš„ç‹¬ç«‹æ€§ä½¿å¾—è®¡ç®—å¯ä»¥å¹¶è¡ŒåŒ–ï¼š

```python
import concurrent.futures

def parallel_projection_demo():
    """æ¼”ç¤ºæ­£äº¤åŸºä¸Šå¹¶è¡ŒæŠ•å½±è®¡ç®—"""
    
    # å¤§å‘é‡å’Œæ­£äº¤åŸº
    vector = np.random.randn(1000)
    orthogonal_basis = [
        np.random.randn(1000) for _ in range(10)
    ]
    
    # æ–½å¯†ç‰¹æ­£äº¤åŒ–ç¡®ä¿åŸºå‘é‡æ­£äº¤
    from scipy.linalg import orth
    orthogonal_basis = orth(np.column_stack(orthogonal_basis)).T
    
    def compute_projection(base_vector):
        """è®¡ç®—åœ¨å•ä¸ªåŸºå‘é‡ä¸Šçš„æŠ•å½±"""
        coefficient = np.dot(vector, base_vector)
        return coefficient * base_vector
    
    # ä¸²è¡Œè®¡ç®—
    import time
    start_time = time.time()
    serial_projections = [compute_projection(base) for base in orthogonal_basis]
    serial_time = time.time() - start_time
    
    # å¹¶è¡Œè®¡ç®—
    start_time = time.time()
    with concurrent.futures.ThreadPoolExecutor() as executor:
        parallel_projections = list(executor.map(compute_projection, orthogonal_basis))
    parallel_time = time.time() - start_time
    
    print(f"ä¸²è¡Œè®¡ç®—æ—¶é—´: {serial_time:.4f}ç§’")
    print(f"å¹¶è¡Œè®¡ç®—æ—¶é—´: {parallel_time:.4f}ç§’")
    print(f"åŠ é€Ÿæ¯”: {serial_time/parallel_time:.2f}x")

# parallel_projection_demo()  # å–æ¶ˆæ³¨é‡Šä»¥è¿è¡Œ
```

## 10. æ€»ç»“ï¼šæ­£äº¤å‘é‡çš„åå¤§è¶…èƒ½åŠ›

| è¶…èƒ½åŠ› | å…·ä½“è¡¨ç° | å®é™…æ”¶ç›Š |
|--------|----------|----------|
| ğŸ§® **è®¡ç®—ç®€åŒ–** | å†…ç§¯ä¸ºé›¶ï¼ŒæŠ•å½±å…¬å¼ç®€å• | ç®—æ³•æ•ˆç‡æå‡ |
| ğŸ›¡ï¸ **æ•°å€¼ç¨³å®š** | é¿å…ç—…æ€çŸ©é˜µé—®é¢˜ | è®¡ç®—æ›´å¯é  |
| ğŸ§­ **å‡ ä½•ç›´è§‚** | æ–¹å‘å®Œå…¨ç‹¬ç«‹ | ç†è§£æ›´å®¹æ˜“ |
| âš¡ **ç®—æ³•ä¼˜åŒ–** | é€†çŸ©é˜µ=è½¬ç½®çŸ©é˜µ | é€Ÿåº¦å¤§å¹…æå‡ |
| ğŸ’¾ **å­˜å‚¨é«˜æ•ˆ** | å‚æ•°åŒ–è¡¨ç¤ºç´§å‡‘ | å†…å­˜ä½¿ç”¨å‡å°‘ |
| ğŸµ **ä¿¡å·åˆ†è§£** | é¢‘åŸŸåˆ†æè‡ªç„¶ | ä¿¡å·å¤„ç†ä¼˜åŒ– |
| ğŸ¤– **æœºå™¨å­¦ä¹ ** | PCAã€æƒé‡åˆå§‹åŒ– | æ¨¡å‹æ€§èƒ½æå‡ |
| ğŸ” **é”™è¯¯æ£€æµ‹** | å¿«é€ŸéªŒè¯ç®—æ³•æ­£ç¡®æ€§ | è°ƒè¯•æ•ˆç‡æé«˜ |
| ğŸš€ **å¹¶è¡Œè®¡ç®—** | ç‹¬ç«‹æ–¹å‘å¹¶è¡Œå¤„ç† | å¤šæ ¸æ€§èƒ½å‘æŒ¥ |
| ğŸ¯ **ç²¾åº¦ä¿æŒ** | è¯¯å·®ä¸ç´¯ç§¯ | é•¿æœŸè®¡ç®—ç¨³å®š |

## ç»“è¯­

å‘é‡æ­£äº¤ä¸ä»…ä»…æ˜¯ä¸€ä¸ªæ•°å­¦æ¦‚å¿µï¼Œå®ƒæ˜¯ç°ä»£è®¡ç®—ç§‘å­¦çš„åŸºçŸ³ã€‚ä»æœ€åŸºç¡€çš„åæ ‡ç³»ç»Ÿåˆ°æœ€å‰æ²¿çš„æ·±åº¦å­¦ä¹ ï¼Œæ­£äº¤æ€§æ— å¤„ä¸åœ¨ï¼Œé»˜é»˜åœ°è®©æˆ‘ä»¬çš„è®¡ç®—å˜å¾—æ›´å¿«ã€æ›´å‡†ã€æ›´ç¨³å®šã€‚

ç†è§£å¹¶å–„ç”¨æ­£äº¤æ€§ï¼Œå°±åƒæŒæ¡äº†æ•°å­¦ä¸–ç•Œçš„"ä¸‡èƒ½é’¥åŒ™"â€”â€”å®ƒèƒ½æ‰“å¼€æ•ˆç‡ã€ç¨³å®šæ€§å’Œä¼˜é›…æ€§çš„å¤§é—¨ï¼

---

**ä½œè€…**: meimeitou  
